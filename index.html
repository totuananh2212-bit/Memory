<!doctype html>
<html lang="vi">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Mini Football 5v5 — Top-down</title>
<style>
  :root{--bg:#073b4c;--panel:#062c3a;--accent:#ffd166}
  body{margin:0;font-family:Inter,system-ui,Arial;background:#001219;color:#e6eef6}
  #app{display:flex;min-height:100vh;gap:12px;padding:12px;box-sizing:border-box}
  /* Left: game canvas with stadium bg image (hotlink) */
  .stage{flex:1;background-image:url('https://media.istockphoto.com/id/1183321688/vi/anh/s%C3%A2n-b%C3%B3ng-%C4%91%C3%A1-t%E1%BB%AB-tr%C3%AAn-cao-minh-h%E1%BB%8Da-2d.jpg?s=170667a&w=0&k=20&c=ZyJmIepSAWUDL3ElvCb1lymNTAP5acmAgDSpg1AmMu0=');background-size:cover;border-radius:8px;padding:12px;display:flex;align-items:center;justify-content:center}
  canvas{background:rgba(0,0,0,0.25);border-radius:6px;box-shadow:0 8px 30px rgba(0,0,0,0.6)}
  /* Right: controls */
  .panel{width:380px;background:linear-gradient(180deg,#02121a,#04232e);border-radius:8px;padding:12px;box-shadow:0 8px 30px rgba(0,0,0,0.6)}
  h2{margin:0 0 8px 0;font-size:16px}
  label{display:block;font-size:13px;color:#9fb6c3;margin-top:8px}
  input[type=color],input[type=text],select,input[type=number]{width:100%;padding:6px;border-radius:6px;border:none;margin-top:6px}
  .row{display:flex;gap:8px}
  .small{font-size:13px;padding:6px;border-radius:6px;background:#064a63;border:none;color:white;cursor:pointer}
  .start{background:#2a9d8f}
  .stop{background:#e63946}
  .team-box{display:flex;gap:8px;align-items:center;padding:6px;background:#033742;border-radius:6px}
  .player-config{border-radius:6px;padding:6px;background:rgba(255,255,255,0.02);margin-top:6px}
  .note{font-size:12px;color:#9fb6c3;margin-top:6px}
  footer{color:#6da6b6;font-size:12px;margin-top:8px}
</style>
</head>
<body>
<div id="app">
  <div class="stage">
    <canvas id="field" width="960" height="600"></canvas>
  </div>
  <div class="panel">
    <h2>Mini Football — 5v5 (3 phút)</h2>
    <div class="row">
      <button id="startBtn" class="small start">Bắt đầu</button>
      <button id="pauseBtn" class="small">Tạm dừng</button>
      <button id="resetBtn" class="small stop">Reset</button>
    </div>

    <label>Chọn đội chơi (bên trái = Đội A, bên phải = Đội B)</label>
    <div class="row" style="margin-top:6px">
      <div class="team-box"><input type="radio" name="controlTeam" id="controlA" value="A" checked> <label for="controlA">Đội A</label></div>
      <div class="team-box"><input type="radio" name="controlTeam" id="controlB" value="B"> <label for="controlB">Đội B</label></div>
    </div>

    <label>Điều khiển</label>
    <div class="note">Di chuyển: WASD hoặc ←↑→↓ (chuẩn), Chuyền/Ghìm/Shot: Space, Chuyển cầu thủ: Tab</div>

    <hr style="margin:8px 0;border-color:rgba(255,255,255,0.04)">

    <h3 style="margin:6px 0">Cấu hình đội</h3>
    <label>Tên đội A</label>
    <input id="teamAName" type="text" value="Blue Sharks">
    <label>Màu áo A</label>
    <input id="teamAColor" type="color" value="#2b6ea3">

    <label>Tên đội B</label>
    <input id="teamBName" type="text" value="Red Lions">
    <label>Màu áo B</label>
    <input id="teamBColor" type="color" value="#d62828">

    <div style="margin-top:8px;font-size:13px;color:#9fb6c3">Chỉnh kỹ năng (0-100). Thủ môn auto do AI.</div>
    <div id="playersConfig"></div>

    <div style="margin-top:8px" class="row">
      <button id="saveCfg" class="small">Lưu cấu hình</button>
      <button id="loadCfg" class="small">Tải cấu hình</button>
    </div>

    <hr style="margin:8px 0;border-color:rgba(255,255,255,0.04)">
    <div id="scoreboard" style="font-size:15px">Thời gian: 03:00 — 0 : 0</div>
    <footer>Made for GitHub Pages. Bạn có thể chỉnh map & player data trong mã (mapData & players)</footer>
  </div>
</div>

<script>
/* ------------------------------
   Mini Football 5v5 Top-down
   - Single-file HTML/JS (Canvas)
   - Features implemented:
     * 5v5 with GK AI
     * Ball physics with bounce (restitution)
     * Goals on left/right (white)
     * Crowd drawn as simple colored dots
     * Menu to customize team names, colors, player names, numbers and skills
     * Player switching, basic control, pass/shoot, 3-minute match timer
   - Notes: not a full AAA game but fully playable and customizable
------------------------------*/

const canvas = document.getElementById('field');
const ctx = canvas.getContext('2d');
const W = canvas.width, H = canvas.height;

// Field dimensions in canvas coords
const pitch = {x: 40, y: 40, w: W-80, h: H-80};
const goalSize = 120; // vertical size of goal opening

// Game state
let running = false, paused = false;
let matchTime = 180; // seconds (3 minutes)
let timer = matchTime; // countdown
let lastTime = 0;
let score = {A:0,B:0};
let controlTeam = 'A';

// Physics
const gravity = 0; // top-down, no gravity
const friction = 0.995; // slows ball

// Ball
let ball = {
  x: W/2, y: H/2,
  vx: 0, vy: 0,
  r: 10,
  mass: 0.3,
  restitution: 0.8
};

// Teams and players setup (5 players each: GK + 4 outfield)
function createDefaultPlayers(){
  const A = [];
  const B = [];
  // Team A on left
  A.push(playerTemplate('A','GK-A',60, {x: pitch.x+30, y: H/2}, true));
  A.push(playerTemplate('A','A1',70, {x: pitch.x+170, y: H/2-120}));
  A.push(playerTemplate('A','A2',75, {x: pitch.x+220, y: H/2-40}));
  A.push(playerTemplate('A','A3',72, {x: pitch.x+220, y: H/2+40}));
  A.push(playerTemplate('A','A4',68, {x: pitch.x+170, y: H/2+120}));
  // Team B on right
  B.push(playerTemplate('B','GK-B',60, {x: pitch.x+pitch.w-30, y: H/2}, true));
  B.push(playerTemplate('B','B1',70, {x: pitch.x+pitch.w-170, y: H/2-120}));
  B.push(playerTemplate('B','B2',75, {x: pitch.x+pitch.w-220, y: H/2-40}));
  B.push(playerTemplate('B','B3',72, {x: pitch.x+pitch.w-220, y: H/2+40}));
  B.push(playerTemplate('B','B4',68, {x: pitch.x+pitch.w-170, y: H/2+120}));
  return {A,B};
}

function playerTemplate(team,name,skill,pos,isGK=false){
  return {
    team, name, number: Math.floor(Math.random()*99)+1,
    x: pos.x, y: pos.y, vx:0, vy:0, r:12,
    speed: 1.6 + (skill/100)*1.6, // base speed influenced by skill
    dribble: skill, pass: skill, shoot: skill, agility: skill,
    isGK: isGK, controlled: false, skill
  };
}

let teams = createDefaultPlayers();
let players = teams.A.concat(teams.B);
let activePlayerIndex = 0; // index in players array of currently selected controlled player
players[activePlayerIndex].controlled = true;

// UI elements
const startBtn = document.getElementById('startBtn');
const pauseBtn = document.getElementById('pauseBtn');
const resetBtn = document.getElementById('resetBtn');
const scoreboard = document.getElementById('scoreboard');
const teamANameEl = document.getElementById('teamAName');
const teamBNameEl = document.getElementById('teamBName');
const teamAColorEl = document.getElementById('teamAColor');
const teamBColorEl = document.getElementById('teamBColor');
const playersConfig = document.getElementById('playersConfig');
const saveCfg = document.getElementById('saveCfg');
const loadCfg = document.getElementById('loadCfg');

// Input state
const keys = {};
window.addEventListener('keydown', e=>{ keys[e.key.toLowerCase()] = true; if(e.key==='Tab'){ e.preventDefault(); switchPlayer(); } });
window.addEventListener('keyup', e=>{ keys[e.key.toLowerCase()] = false; });

// Build players config UI
function buildPlayersConfig(){
  playersConfig.innerHTML = '';
  ['A','B'].forEach(teamId=>{
    const container = document.createElement('div');
    container.innerHTML = `<div style="margin-top:8px;font-weight:bold">Team ${teamId}</div>`;
    const teamPlayers = players.filter(p=>p.team===teamId);
    teamPlayers.forEach((p,idx)=>{
      const div = document.createElement('div'); div.className='player-config';
      div.innerHTML = `
        <div style="display:flex;gap:8px;align-items:center"><input type="text" data-idx="${players.indexOf(p)}" class="pname" value="${p.name}" style="flex:1"><input type="number" min="1" max="99" data-idx="${players.indexOf(p)}" class="pnum" value="${p.number}" style="width:70px"></div>
        <div style="display:flex;gap:8px;margin-top:6px"><label style="flex:1">Skill<input type="range" data-idx="${players.indexOf(p)}" class="pskill" min="10" max="100" value="${p.skill}"></label></div>
      `;
      container.appendChild(div);
    });
    playersConfig.appendChild(container);
  });
}
buildPlayersConfig();

saveCfg.addEventListener('click', ()=>{
  // save team names/colors and players' names/numbers/skills
  const cfg = {teamA:teamANameEl.value,teamB:teamBNameEl.value, colorA:teamAColorEl.value, colorB:teamBColorEl.value, players:[]};
  document.querySelectorAll('.pname').forEach(inp => { const idx=+inp.dataset.idx; cfg.players[idx]=cfg.players[idx]||{}; cfg.players[idx].name=inp.value; });
  document.querySelectorAll('.pnum').forEach(inp => { const idx=+inp.dataset.idx; cfg.players[idx]=cfg.players[idx]||{}; cfg.players[idx].number=+inp.value; });
  document.querySelectorAll('.pskill').forEach(inp => { const idx=+inp.dataset.idx; cfg.players[idx]=cfg.players[idx]||{}; cfg.players[idx].skill=+inp.value; });
  localStorage.setItem('miniSoccerCfg', JSON.stringify(cfg));
  applyConfig(cfg);
  alert('Đã lưu cấu hình.');
});
loadCfg.addEventListener('click', ()=>{ const c=JSON.parse(localStorage.getItem('miniSoccerCfg')||'null'); if(c) applyConfig(c); else alert('Không có config.'); });

function applyConfig(cfg){
  if(!cfg) return;
  teamANameEl.value = cfg.teamA || teamANameEl.value;
  teamBNameEl.value = cfg.teamB || teamBNameEl.value;
  teamAColorEl.value = cfg.colorA || teamAColorEl.value;
  teamBColorEl.value = cfg.colorB || teamBColorEl.value;
  if(cfg.players) cfg.players.forEach((pp, idx)=>{
    if(!players[idx]) return;
    if(pp.name) players[idx].name = pp.name;
    if(pp.number) players[idx].number = pp.number;
    if(pp.skill){ players[idx].skill = pp.skill; players[idx].speed = 1.6 + (pp.skill/100)*1.6; players[idx].dribble = pp.skill; players[idx].pass = pp.skill; players[idx].shoot = pp.skill; players[idx].agility = pp.skill; }
  });
  buildPlayersConfig();
}

// Switch controlled player (tab)
function switchPlayer(){
  // switch among players of selected controlTeam
  const cTeam = document.querySelector('input[name=controlTeam]:checked').value;
  const teamPlayers = players.map((p,i)=>({p,i})).filter(o=>o.p.team===cTeam && !o.p.isGK);
  if(teamPlayers.length===0) return;
  // find current index in teamPlayers
  let cur = teamPlayers.findIndex(o=>o.p.controlled);
  // if none controlled in team, pick first
  if(cur===-1) cur = 0; else {
    // switch to next
    teamPlayers[cur].p.controlled = false;
    cur = (cur+1)%teamPlayers.length;
  }
  // mark controlled
  teamPlayers.forEach(o=>o.p.controlled=false);
  const selected = teamPlayers[cur];
  selected.p.controlled = true;
  // set globals
  activePlayerIndex = selected.i;
}

// Utility distance
function dist(a,b){ const dx=a.x-b.x, dy=a.y-b.y; return Math.hypot(dx,dy); }

// Ball collisions with players
function resolveBallPlayerCollision(player){
  const dx = ball.x - player.x, dy = ball.y - player.y;
  const d = Math.hypot(dx,dy);
  const minD = ball.r + player.r;
  if(d < minD){
    // push ball out
    const nx = dx/d, ny = dy/d;
    const overlap = minD - d + 0.1;
    ball.x += nx*overlap; ball.y += ny*overlap;
    // relative velocity
    const relVx = ball.vx - player.vx, relVy = ball.vy - player.vy;
    const rel = relVx*nx + relVy*ny;
    if(rel < 0){
      const e = ball.restitution;
      const j = -(1+e)*rel/(1/ball.mass);
      ball.vx += (j*nx)/ball.mass; ball.vy += (j*ny)/ball.mass;
    }
  }
}

// Player simple AI (move towards ball or predefined role)
function playerAI(p, dt){
  if(p.isGK){
    // GK: stay near goal x and follow ball vertically
    const goalX = p.team==='A' ? pitch.x+10 : pitch.x + pitch.w -10;
    const targetY = Math.min(Math.max(ball.y, pitch.y+30), pitch.y+pitch.h-30);
    const dx = goalX - p.x; const dy = targetY - p.y;
    p.vx = Math.sign(dx)*Math.min(Math.abs(dx), p.speed*0.9);
    p.vy = Math.sign(dy)*Math.min(Math.abs(dy), p.speed*0.9);
    p.x += p.vx; p.y += p.vy;
    // if ball close to goal and pointed at goal, dive (simplified)
    return;
  }
  // If teammate controlled by human, skip AI
  if(p.controlled && p.team === controlTeam) return;
  // Basic behavior: if our team has ball, move to attack/defend; else chase ball
  const teamHasBall = possession() === p.team;
  let tx = ball.x, ty = ball.y;
  if(teamHasBall && p.team === possession()){ // offensive position: move forward
    tx = p.team==='A' ? p.x + 60 : p.x - 60;
    ty = p.y; }
  // move towards (tx,ty)
  const dx = tx - p.x, dy = ty - p.y; const d = Math.hypot(dx,dy);
  if(d>1){ p.vx = (dx/d)*p.speed; p.vy = (dy/d)*p.speed; } else { p.vx=0; p.vy=0; }
  p.x += p.vx; p.y += p.vy;
}

// Determine possession: which team has ball (closest player within threshold)
function possession(){
  let minD = 9999, owner = null;
  players.forEach(p=>{ const d = Math.hypot(ball.x-p.x, ball.y-p.y); if(d < minD){ minD = d; owner = p; } });
  if(minD < 20) return owner.team; return null;
}

// Kick / pass / shoot when player presses space
function playerKick(p){
  // determine if near ball
  const d = Math.hypot(ball.x-p.x, ball.y-p.y);
  if(d > 40) return; // too far
  // power & direction
  // if near goal -> shoot, else pass forward in facing direction (here: towards mouse or forward)
  let power = 6 + (p.shoot/100)*8;
  // find target: if human controlled, shoot towards mouse position when clicked? We'll aim towards opponent goal when hold shift
  const ctrlTeam = document.querySelector('input[name=controlTeam]:checked').value;
  const isHuman = p.team === ctrlTeam && p.controlled;
  let tx, ty;
  if(isHuman){ // aim with mouse position stored globally
    if(window.aimPos){ tx = window.aimPos.x; ty = window.aimPos.y; }
    else { tx = p.team==='A' ? pitch.x+pitch.w : pitch.x; ty = H/2; }
  } else {
    // AI aim: if near opponent goal, shoot; else pass to nearest teammate ahead
    const oppGoalX = p.team==='A' ? pitch.x+pitch.w : pitch.x;
    // find teammate forward
    const mates = players.filter(m=>m.team===p.team && m!==p && !m.isGK);
    const forward = mates.reduce((best,m)=>{ const score = (p.team==='A' ? m.x - p.x : p.x - m.x) - Math.hypot(m.y-p.y, m.x-p.x); if(!best||score>best.score) return {m,score}; return best; }, null);
    if(forward && forward.score>10){ tx = forward.m.x; ty = forward.m.y; power = 5+(p.pass/100)*5; }
    else { tx = oppGoalX; ty = H/2; power = 8+(p.shoot/100)*6; }
  }
  // set ball velocity toward (tx,ty)
  const dx = tx - ball.x, dy = ty - ball.y; const d = Math.hypot(dx,dy)||1;
  ball.vx = (dx/d) * power; ball.vy = (dy/d) * power;
}

// Check goal
function checkGoal(){
  // left goal area
  const leftGoalX = pitch.x; const rightGoalX = pitch.x+pitch.w;
  if(ball.x - ball.r < leftGoalX){
    // check vertical within goal mouth (centered)
    const gyTop = H/2 - goalSize/2, gyBottom = H/2 + goalSize/2;
    if(ball.y > gyTop && ball.y < gyBottom){ // goal for B
      score.B++; resetAfterGoal('B');
    } else { // hit post/wall
      ball.x = leftGoalX + ball.r; ball.vx *= -ball.restitution; }
  }
  if(ball.x + ball.r > rightGoalX){
    const gyTop = H/2 - goalSize/2, gyBottom = H/2 + goalSize/2;
    if(ball.y > gyTop && ball.y < gyBottom){ score.A++; resetAfterGoal('A'); }
    else { ball.x = rightGoalX - ball.r; ball.vx *= -ball.restitution; }
  }
}

function resetAfterGoal(scoringTeam){
  // brief pause
  running = false; setTimeout(()=>{ running = true; }, 1200);
  // reset positions
  ball.x = W/2; ball.y = H/2; ball.vx = ball.vy = 0;
  // move players back
  teams = createDefaultPlayers(); players = teams.A.concat(teams.B);
  applyConfig(JSON.parse(localStorage.getItem('miniSoccerCfg')||'{}'));
  buildPlayersConfig();
}

// Bound players within pitch
function boundPlayer(p){
  p.x = Math.max(pitch.x+10, Math.min(pitch.x+pitch.w-10, p.x));
  p.y = Math.max(pitch.y+10, Math.min(pitch.y+pitch.h-10, p.y));
}

// Ball bounce with pitch walls
function ballWallCollision(){
  const left = pitch.x+10, right = pitch.x+pitch.w-10, top = pitch.y+10, bottom = pitch.y+pitch.h-10;
  if(ball.x - ball.r < left){ ball.x = left + ball.r; ball.vx *= -ball.restitution; }
  if(ball.x + ball.r > right){ ball.x = right - ball.r; ball.vx *= -ball.restitution; }
  if(ball.y - ball.r < top){ ball.y = top + ball.r; ball.vy *= -ball.restitution; }
  if(ball.y + ball.r > bottom){ ball.y = bottom - ball.r; ball.vy *= -ball.restitution; }
}

// Main update
function update(dt){
  if(!running || paused) return;
  // timer
  timer -= dt/1000; if(timer<=0){ running=false; alert('Hết giờ! Kết quả: '+teamANameEl.value+' '+score.A+' - '+score.B+' '+teamBNameEl.value); resetMatch(); }

  // players AI / input
  players.forEach((p,i)=>{
    if(p.team === controlTeam && p.controlled){
      // human control for currently controlled players
      let mvx=0,mvy=0;
      if(keys['arrowup']||keys['w']) mvy -= p.speed;
      if(keys['arrowdown']||keys['s']) mvy += p.speed;
      if(keys['arrowleft']||keys['a']) mvx -= p.speed;
      if(keys['arrowright']||keys['d']) mvx += p.speed;
      p.vx = mvx; p.vy = mvy;
      p.x += p.vx; p.y += p.vy;
      boundPlayer(p);
      // kick
      if(keys[' ']){ if(!p._spaceLock){ playerKick(p); p._spaceLock=true; } } else p._spaceLock=false;
    } else {
      playerAI(p, dt);
      boundPlayer(p);
    }
  });

  // Ball physics
  ball.vx *= friction; ball.vy *= friction;
  ball.x += ball.vx; ball.y += ball.vy;
  ballWallCollision();
  // collisions with players
  players.forEach(p=> resolveBallPlayerCollision(p));
  checkGoal();
}

function resetMatch(){
  timer = matchTime; score = {A:0,B:0}; running=false; paused=false; ball.x=W/2; ball.y=H/2; ball.vx=0; ball.vy=0; teams=createDefaultPlayers(); players=teams.A.concat(teams.B); applyConfig(JSON.parse(localStorage.getItem('miniSoccerCfg')||'{}'));
  buildPlayersConfig(); activePlayerIndex=0; players[activePlayerIndex].controlled=true;
}

// Draw routines
function drawField(){
  // pitch background
  ctx.fillStyle = '#2a6f6f'; ctx.fillRect(pitch.x, pitch.y, pitch.w, pitch.h);
  // lines
  ctx.strokeStyle = '#ffffff55'; ctx.lineWidth=2; ctx.strokeRect(pitch.x, pitch.y, pitch.w, pitch.h);
  // center line
  ctx.beginPath(); ctx.moveTo(pitch.x + pitch.w/2, pitch.y); ctx.lineTo(pitch.x + pitch.w/2, pitch.y+pitch.h); ctx.stroke();
  // center circle
  ctx.beginPath(); ctx.arc(pitch.x+pitch.w/2, pitch.y+pitch.h/2, 60, 0, Math.PI*2); ctx.stroke();
  // goals (white rectangles outside pitch)
  ctx.fillStyle='#ffffff'; const gyTop = H/2 - goalSize/2; ctx.fillRect(pitch.x-10, gyTop, 10, goalSize); ctx.fillRect(pitch.x+pitch.w, gyTop, 10, goalSize);
}

function drawCrowd(){
  // simple crowd dots beyond pitch
  const left = 0, right = W, top = 0, bottom = H;
  // top stands
  for(let i=0;i<120;i++){
    const x = Math.random()*W; const y = Math.random()*30; ctx.fillStyle = randomCrowdColor(); ctx.fillRect(x,y,4,4);
  }
  // bottom stands
  for(let i=0;i<120;i++){
    const x = Math.random()*W; const y = H- (Math.random()*30); ctx.fillStyle = randomCrowdColor(); ctx.fillRect(x,y,4,4);
  }
}
function randomCrowdColor(){ const palette=['#ffd166','#ef476f','#06d6a0','#118ab2','#073b4c']; return palette[Math.floor(Math.random()*palette.length)]; }

function drawPlayers(){
  players.forEach(p=>{
    // shadow
    ctx.beginPath(); ctx.fillStyle = 'rgba(0,0,0,0.3)'; ctx.ellipse(p.x+4,p.y+6,p.r*0.9,p.r*0.5,0,0,Math.PI*2); ctx.fill();
    // body
    ctx.beginPath(); ctx.fillStyle = p.team==='A'?teamAColorEl.value:teamBColorEl.value; ctx.arc(p.x,p.y,p.r,0,Math.PI*2); ctx.fill();
    // number
    ctx.fillStyle='#fff'; ctx.font='12px sans-serif'; ctx.textAlign='center'; ctx.textBaseline='middle'; ctx.fillText(p.number,p.x,p.y);
    // outline if controlled
    if(p.controlled){ ctx.lineWidth=2; ctx.strokeStyle='#fff'; ctx.beginPath(); ctx.arc(p.x,p.y,p.r+3,0,Math.PI*2); ctx.stroke(); }
  });
}

function drawBall(){ ctx.beginPath(); ctx.fillStyle='#fff'; ctx.arc(ball.x,ball.y,ball.r,0,Math.PI*2); ctx.fill(); ctx.strokeStyle='#d0d0d0'; ctx.stroke(); }

function render(){
  ctx.clearRect(0,0,W,H);
  // semi-transparent stadium overlay to blend with background image
  ctx.fillStyle='rgba(0,0,0,0.25)'; ctx.fillRect(0,0,W,H);
  drawField();
  drawPlayers();
  drawBall();
  // HUD
  ctx.fillStyle='#fff'; ctx.font='14px sans-serif'; ctx.textAlign='left'; ctx.fillText(teamANameEl.value + ' ' + score.A, 12, 18);
  ctx.textAlign='right'; ctx.fillText(score.B + ' ' + teamBNameEl.value, W-12, 18);
}

// Main loop
function loop(ts){
  const dt = Math.min(40, ts - lastTime); lastTime = ts;
  update(dt);
  render();
  // update scoreboard text
  const mm = Math.floor(timer/60); const ss = Math.floor(timer%60).toString().padStart(2,'0');
  scoreboard.textContent = `Thời gian: ${mm}:${ss} — ${score.A} : ${score.B}`;
  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);

// UI buttons
startBtn.addEventListener('click', ()=>{ running=true; paused=false; });
pauseBtn.addEventListener('click', ()=>{ paused=!paused; });
resetBtn.addEventListener('click', ()=>{ resetMatch(); running=false; });

// mouse aim (for human shooting)
window.aimPos = null; canvas.addEventListener('mousemove', e=>{ const rect=canvas.getBoundingClientRect(); window.aimPos = {x:e.clientX-rect.left, y:e.clientY-rect.top}; });
canvas.addEventListener('click', e=>{ // on click, controlled player shoots towards click
  const p = players.find(p=>p.controlled && p.team===document.querySelector('input[name=controlTeam]:checked').value);
  if(p) playerKick(p);
});

// initialize
applyConfig(JSON.parse(localStorage.getItem('miniSoccerCfg')||'{}'));
buildPlayersConfig();

</script>
</body>
</html>
